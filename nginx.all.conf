events { }

http {
    resolver 127.0.0.11 valid=30s;  # Docker의 내장 DNS 사용

    limit_req_zone $binary_remote_addr zone=ip_limit:10m rate=30r/s;

    server {
        listen 80; # Nginx가 요청을 받을 포트 설정
        server_name steach.ssafy.io;
        # HTTP 요청을 HTTPS로 리디렉션
        return 301 https://$host$request_uri;
    }

    upstream steach-server {
        server steach-server:8080; # steach-server 애플리케이션이 사용하는 포트 설정
        server 127.0.0.1:65535 backup;  # 더미 서버
    }

    upstream steach-front {
        server steach-front:5173; # steach-server 애플리케이션이 사용하는 포트 설정
        server 127.0.0.1:65535 backup;  # 더미 서버
    }

    server {
        listen 443 ssl;
        server_name steach.ssafy.io;

        ssl_certificate /etc/letsencrypt/live/steach.ssafy.io/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/steach.ssafy.io/privkey.pem;

#         # root 지시어는 웹 서버가 제공할 파일의 루트 디렉터리를 지정합니다.
#         # 여기서는 /home/ubuntu/S11P12D201/combined/dist 디렉터리를 사용합니다.
#         root /home/ubuntu/S11P12D201combined//dist;


        # index 지시어
        # index 지시어는 디렉터리가 요청될 때 기본으로 제공될 인덱스 파일을 지정합니다.
        # 이는 사용자가 특정 파일을 지정하지 않고 디렉터리 URL에 접근할 때, 기본적으로 제공되는 HTML 파일을 설정하는 데 사용됩니다.
        # index 지시어는 기본 인덱스 파일을 지정합니다. 여기서는 index.html을 사용합니다.
#         목적: 사용자가 https://example.com/와 같이 디렉터리에 접근할 때, nginx가 해당 디렉터리에서 index.html 파일을 찾도록 합니다.
#         동작: 디렉터리 내에 index.html 파일이 존재하면 이를 사용자에게 제공하고, 존재하지 않으면 다른 설정 지시어에 따라 처리하거나 오류를 반환합니다.
        index index.html;

#       error_page 지시어는 오류가 발생했을 때 사용자에게 보여줄 커스텀 페이지를 지정하는 데 사용됩니다.
#       예를 들어, 404 Not Found 오류가 발생했을 때, 기본 서버 오류 메시지 대신 사용자 친화적인 오류 페이지를 제공할 수 있습니다.
#       목적: 404 Not Found 오류가 발생할 때 nginx가 /index.html 파일을 제공하도록 합니다.
#       동작: 요청된 리소스를 찾을 수 없어 404 오류가 발생하면, nginx는 루트 디렉터리에서 index.html 파일을 제공하게 됩니다. 이는 주로 Single Page Application(SPA)에서 클라이언트 측 라우팅을 처리하기 위해 사용됩니다.
        error_page 404 /index.html;

        # location 블록:
        # try_files $uri /index.html; 지시어는 요청된 파일이 존재하지 않을 경우 /index.html을 반환하도록 설정합니다.
        # 이는 SPA에서 클라이언트 측 라우팅을 지원하기 위한 설정입니다.
        location / {
            proxy_pass http://steach-front; # 요청을 steach-front 애플리케이션으로 전달
             proxy_set_header Host $host; # 원본 호스트 헤더 전달
            proxy_set_header X-Real-IP $remote_addr; # 클라이언트의 IP 주소 전달
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 프록시를 통한 클라이언트 IP 주소 전달
            proxy_set_header X-Forwarded-Proto $scheme; # 요청 프로토콜 전달
            try_files $uri /index.html;
        }

        location /api {
            proxy_pass http://steach-server; # 요청을 steach-server 애플리케이션으로 전달
            proxy_set_header Host $host; # 원본 호스트 헤더 전달
            proxy_set_header X-Real-IP $remote_addr; # 클라이언트의 IP 주소 전달
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 프록시를 통한 클라이언트 IP 주소 전달
            proxy_set_header X-Forwarded-Proto $scheme; # 요청 프로토콜 전달
        }

        # 테스트도 포함
        # 2개의 요청 같이 처리 (대소문자 구분)
        location ~ ^/api/v1/(lectures/final/|check/server) {
            # burst=0 은 에러가 나서 없애줘야함
            # [이름] [적용 기술:nodelay, delay] burst: [순간 추가 허용 요청 허용 개수]
            limit_req zone=ip_limit nodelay; # 요청 속도 제한 적용
            limit_req_status 429; # 429 (Too Many Requests) 에러 반환

            proxy_pass http://steach-server; # 요청을 steach-server 애플리케이션으로 전달
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }

    # 일반 로그 설정
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';
    access_log /var/log/nginx/access.log main; # main은 로그 형식을 지정하는 이름
    error_log /var/log/nginx/error.log; # 경로 log_level  # 기본 로그 레벨은 error입니다.

    # 커스텀 로그 포맷 설정
    log_format custom_log_format '$remote_addr - $remote_user [$time_local] "$request" '
                                 'limit_req_status=$limit_req_status $status '
                                 '"$http_referer" "$http_user_agent"';
    access_log /var/log/nginx/access.log custom_log_format;
}